#' Hotelling's parametric test for the mean
#'
#' \code{parametric_test} performs a parametric test for the mean (or for the
#' difference between the means) of populations of curves based on Hotelling's
#' T^2 statistic.
#'
#' @inheritParams statistics
#' @param skip_check Flag to skip checks on input types. Default is off. This
#'   parameter should always be set to its default \code{FALSE}. It is set to
#'   \code{TRUE} only internally, in power calculation functions, in which data
#'   generated by the hypothesized model is already in matrix form.
#' @return A 3-column \code{\link[dplyr]{data_frame}} containing the names of
#'   the required statistics and their values, along with an estimate of the
#'   p-value of the corresponding statistical test. This function uses
#'   exclusively Hotelling's T^2 statistic. Hence, the output
#'   \code{\link[dplyr]{data_frame}} only has 1 row displaying information
#'   about Hotelling's statistic.
#' @seealso This test is described in details in Secchi, P., Stamm, A., &
#'   Vantini, S. (2013). \emph{Inference for the mean of large \eqn{p} small
#'   \eqn{n} data: A finite-sample high-dimensional generalization of
#'   Hotelling theorem}. Electronic Journal of Statistics, 7, pp. 2005-2031.
#'   doi:10.1214/13-EJS833, available online at
#'   \url{http://projecteuclid.org/euclid.ejs/1375708877}.
#' @examples
#' x <- aneurisk %>%
#'  dplyr::filter(variable == "curvature" & group == "low") %>%
#'  dplyr::select(data) %>%
#'  purrr::flatten_df()
#' y <- aneurisk %>%
#'  dplyr::filter(variable == "curvature" & group == "up") %>%
#'  dplyr::select(data) %>%
#'  purrr::flatten_df()
#' step_size <- aneurisk$abscissa[[1]][2] - aneurisk$abscissa[[1]][1]
#' parametric_test(x = x, y = y, mu = 0, step_size = step_size)
#' @export
parametric_test <- function(x, y = NULL, mu = NULL,
                            paired = FALSE, step_size = 0, skip_check = FALSE) {
  if (!skip_check) {
    l <- check_arguments(x = x, y = y, mu = mu, step_size = step_size)
    x <- l$x
    y <- l$y
    mu <- l$mu
  }
  oneSample <- dim(y)[2] == 0
  p <- dim(x)[2]
  if (!oneSample && dim(y)[2] != p)
    stop("Both groups should have the same number of components.")
  nx <- dim(x)[1]
  ny <- ifelse(oneSample, 1, dim(y)[1])
  stat <- stat_hotelling_impl(x = x, y = y, mu = mu,
                             paired = paired, step_size = step_size,
                             use_correction = TRUE)
  df1 <- min(nx + ny - 2, p)
  df2 <- abs(nx + ny - 2 - p) + 1
  pvalue <- 1 - stats::pf(stat, df1, df2)
  dplyr::data_frame(
    statName = names(stat),
    statVal = stat,
    pValue = pvalue
  )
}

#' Permutation test for the mean
#'
#' \code{permutation_test} performs a non-parametric test for the mean function
#'  of a single population of curves or for the difference between mean
#'  functions of two populations of curves. The one-population test is based on
#'  central symmetry and reflexions around the mean function while the
#'  two-population test rely on permutations.
#'
#' All the statistics of the \pkg{fdahotelling} package can be embedded in this
#'  test. In addition, the user can implement its own statistic to be used with
#'  the test, provided that:
#'  \itemize{
#'  \item the user-defined statistic takes the same input arguments as the ones
#'    in the \pkg{fdahotelling} package, i.e., the mandatory first dataset
#'    \code{x}, the optional second dataset \code{y} and the mean function under
#'    the null hypothesis \code{mu} that can have a default value,
#'  \item high values of the statistic yield rejection of the null hypothesis.
#'  }
#'
#' @inheritParams parametric_test
#' @param B Number of bootstrap permutations (default: 1000).
#' @param statistic Statistic to be used within the permutation framework.
#'   Choices are Hotelling (default), L1, L2, Linf, StandardizedL1,
#'   StandardizedL2, StandardizedLinf and All.
#' @param verbose Activate verbose (default: \code{TRUE}).
#' @return A 3-column \code{\link[dplyr]{data_frame}} containing the names of
#'   the required statistics and their values, along with an estimate of the
#'   p-value of the corresponding statistical test.
#' @seealso This test is described in details in the technical report by Pini,
#'   A., Stamm, A., & Vantini, S. (2015). \emph{Hotelling \eqn{T^2} in
#'   functional Hilbert spaces}, available online at
#'   \url{https://mox.polimi.it/publication-results/?id=524&tipo=add_qmox}.
#' @importFrom dplyr mutate data_frame
#' @importFrom purrr map map2 map_dbl transpose simplify_all
#' @examples
#' x <- aneurisk %>%
#'  dplyr::filter(variable == "curvature" & group == "low") %>%
#'  dplyr::select(data) %>%
#'  purrr::flatten_df()
#' y <- aneurisk %>%
#'  dplyr::filter(variable == "curvature" & group == "up") %>%
#'  dplyr::select(data) %>%
#'  purrr::flatten_df()
#' step_size <- aneurisk$abscissa[[1]][2] - aneurisk$abscissa[[1]][1]
#' permutation_test(x = x, y = y, mu = 0,
#'  statistic = "All", step_size = step_size)
#' @export
permutation_test <- function(x, y = NULL, mu = 0,
                             paired = FALSE, step_size = 0,
                             B = 1000, statistic = "Hotelling", verbose = TRUE,
                             skip_check = FALSE) {
  if (!skip_check) {
    l <- check_arguments(x = x, y = y, mu = mu, step_size = step_size)
    x <- l$x
    y <- l$y
    mu <- l$mu
  }

  oneSample <- dim(y)[2] == 0

  stat_fun <- switch (statistic,
    "Hotelling" = stat_hotelling_impl,
    "L1" = stat_L1_impl,
    "L2" = stat_L2_impl,
    "Linf" = stat_Linf_impl,
    "StandardizedL1" = stat_L1_std_impl,
    "StandardizedL2" = stat_L2_std_impl,
    "StandardizedLinf" = stat_Linf_std_impl,
    "All" = stat_all_impl,
    stop("Unrecognised statistic. Please choose between Hotelling, L1, L2, Linf,
         StandardizedL1, StandardizedL2, StandardizedLinf and All.")
  )

  # Get statistic value
  stat <- stat_fun(x = x, y = y, mu = mu,
                    paired = paired, step_size = step_size)

  if (oneSample)
    boot_data <- permutation_test.onepop(x, mu, step_size, B,
                                         stat_fun, verbose)
  else
    boot_data <- permutation_test.twopop(x, y, mu, paired, step_size,
                                         B, stat_fun, verbose)

  boot_data %>%
    mutate(test = map(stat_boot, `>=`, stat)) %>%
    `$`(test) %>%
    transpose() %>%
    simplify_all() %>%
    map_dbl(mean) %>%
    data_frame(statName = names(.), statVal = stat, pValue = .)
}

permutation_test.onepop <- function(x, mu, step_size, B, statistic, verbose) {
  n <- dim(x)[1]
  p <- dim(x)[2]

  # Decide on bootstrap vs exact test
  n_comb <- 2^n
  p_min <- 1 / min(B, n_comb)
  if (verbose)
    writeLines(paste(" - P-value resolution:", p_min))
  exactTest <- B >= n_comb
  if (exactTest) { # Case of exact test
    B <- t(expand.grid(rep(list(c(0, 1)), n)))
    if (verbose) {
      writeLines(" - Computing exact p-value.")
      writeLines(paste(" - P-value will never drop below", p_min))
    }
  } else { # Case of approximate test
    n_comb <- B
    if (verbose) {
      writeLines(paste(" - Computing approximate p-value using",
                       B, "random reflexions."))
      writeLines(paste(" - P-value will not drop below", 1 / n_comb, "in average."))
    }
  }

  matrixMu <- matrix(data = mu, nrow = n, ncol = p, byrow = TRUE)
  y <- matrix(nrow = 0, ncol = 0)

  data_frame(bootId = seq_len(n_comb)) %>%
    mutate(
      r = map(bootId, ~ if (exactTest) {
        B[, .x]
      } else {
        sample.int(n = 2, size = n, replace = TRUE) - 1
      }),
      data = map(r, ~ matrixMu + diag((-1)^(.x)) %*% (x - matrixMu)),
      stat_boot = map(data, statistic, y = y, mu = mu, step_size = step_size)
    )
}

permutation_test.twopop <- function(x, y, mu, paired, step_size, B, statistic,
                                    verbose) {
  if (dim(y)[2] != dim(x)[2])
    stop("Both groups should have the same number of components.")

  # Get sample sizes
  nx <- dim(x)[1]
  ny <- dim(y)[1]
  px <- nx / (nx + ny)
  py <- ny / (nx + ny)

  # Decide on MC vs exact test
  n_comb <- choose(nx + ny, nx)
  p_min <- 1 / min(B, n_comb)
  if (verbose)
    writeLines(paste(" - P-value resolution:", p_min))
  if (B >= n_comb) { # Case of exact test
    B <- combn(nx + ny, nx)
    if (verbose) {
      writeLines(" - Computing exact p-value.")
      writeLines(paste(" - P-value will never drop below", p_min))
    }
  } else { # Case of approximate test
    if (verbose) {
      writeLines(paste(" - Computing approximate p-value using",
                       B, "random permutations."))
      writeLines(paste(" - P-value will not drop below",
                       1 / n_comb, "in average."))
    }
  }

  # Generate boostrap data
  rbind(x, y) %>%
    partition(B, c(D1 = px, D2 = py)) %>%
    mutate(stat_boot = map2(D1, D2, statistic, mu = mu,
                            paired = paired, step_size = step_size))
}
